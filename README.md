Introduction:

For this project, my goal is to implement the game of Snake. The player will be able to interact with the game through a joystick. An 8x8 LED matrix will be used for displaying the game graphics, while the player's score will be shown on an LCD screen.

General Description:

As mentioned earlier, the player will control the direction of movement through the joystick. Additionally, by pressing the joystick button, the player can change the game's difficulty level (speed of movement). Throughout the game, the current score will be displayed on the LCD screen. When the player loses, the game will end, and an appropriate message will be displayed on the screen.

The communication between the LCD screen and the Arduino board will be done using an I2C adapter, reducing the number of pins required. For the joystick, the two direction pins will be connected to analog inputs, while the button will be connected to one of the digital pins on the board.

The block diagram of the project is as follows:

![joc_snake_schema_generala drawio](https://user-images.githubusercontent.com/79792580/227972006-8cd22d2c-9b60-44f8-9f16-ba8b47eea793.png)

Hardware Design:

The components used for this project are:

Atmega 328P
8x8 RGB LED matrix
1602 LCD module
I2C adapter for the LCD
2-axis joystick module with a button

The electrical scheme is as following:
![coman_robert_schema_electrica](https://user-images.githubusercontent.com/79792580/227972781-d126224d-2f7b-44db-9ab9-e8b1e5f2b1df.png)

The connection diagram is as follows: The RGB LED matrix is connected to pin PD6. To communicate with the LCD through the I2C adapter, pins A4 and A5 (SDA and SCL) are used. The two axes of the joystick are connected to analog pins A0 and A1, and its button is connected to digital pin PD2.

Software Design:
For development, the Arduino IDE 1.8.19 was used. The "Adafruit_NeoPixel" library was used to control the RGB LED matrix, while the "LiquidCrystal_I2C" library was used to control the LCD through the I2C adapter.

The game works as follows: initially, the snake is of size 1, and its head is represented by a yellow LED. The prey is represented by a green LED. When the snake "eats" the prey, its size increases by one unit. The rest of the LEDs that make up the snake are red. The direction in which the snake moves is controlled by the joystick. Thus, if the snake is moving horizontally, a change in direction means that it will move vertically (up or down, depending on the value read on the analog pin). By pressing the joystick button, the player can control the speed, with three speed/difficulty levels. To update the matrix, timer interrupts are used. Thus, when the OCR1A value is reached, the ISR(TIMER1_COMPA_vect) interrupt is triggered, in which the LEDs from the previous step are turned off and turned on in the new position. The value put in the OCR1A register influences the difficulty of the game. The lower this value, the more frequently the interrupt will be triggered, so the snake will move faster. Thus, the value in OCR1A will be modified when the joystick button is pressed during the game. Between two successive interrupts generated by the timer, an attempt is made to read the value from the corresponding joystick axis (if the snake is moving horizontally, an attempt will be made to read a value on the specific vertical axis pin, and vice versa). When the read value exceeds a certain threshold, the next RGB matrix configuration will be calculated, and then the interrupt will be triggered and the previously calculated LEDs will be displayed. Also, when the joystick button is pressed, the ISR(INT0_vect) interrupt will be triggered.

Variables used:

uint8_t snake_body[NUMPIXELS] → a vector containing the LEDs that make up the snake (each LED has a value between 0 and 63 that represents its position)

game_state → the game state: can be RUNNING or GAME_OVER. While the game is in the GAME_OVER state, it waits for a button press to restart, and the snake LEDs blink intermittently

was_read → a value of the joystick must be read only once that is above the tolerance threshold, between two timer interrupts

unsigned int speed[MAX_LEVEL]; → OCR1A register values (game speed)

analog_pin → the pin from which the reading is made (A0 or A1)


Functions used:

bool check_input_detected() → checks if a valid reading has been made

void start_game() → initializes the starting settings of the game: the position of the snake, the position of the prey, the score, etc.

void compute_next_position() → will update the snake_body vector; also checks if the snake has eaten the prey and if it has collided with itself; called in loop if a valid reading has been detected or in the interrupt generated by the timer, if the movement direction has not changed

void print_score() and void print_game_over() → display the score on the LCD

void display_running() → turns on the snake and prey LEDs

void display_game_over() → called in the interrupt while the game is in the GAME_OVER state; will turn off and turn on the snake LEDs

